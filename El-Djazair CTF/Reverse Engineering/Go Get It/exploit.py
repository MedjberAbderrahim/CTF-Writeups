#!/usr/bin/env python3
import base64

def decode_flag():
    print("=== CTF Flag Analysis ===\n")
    
    # The flag must be exactly 48 characters long
    print("1. Flag length: 48 characters")
    
    # First 14 characters are checked with memequal
    prefix = "El-DjazairCTF{"
    print(f"2. Prefix (first 14 chars): '{prefix}'")
    
    # Characters 14-24 are checked individually
    print("3. Characters 14-24 (individual checks):")
    chars_14_24 = []
    
    # a1[14] == 102 -> 'f'
    chars_14_24.append(chr(102))
    print(f"   [14]: {102} -> '{chr(102)}'")
    
    # a1[15] == 121 -> 'y'
    chars_14_24.append(chr(121))
    print(f"   [15]: {121} -> '{chr(121)}'")
    
    # a1[16] == 110 -> 'n'
    chars_14_24.append(chr(110))
    print(f"   [16]: {110} -> '{chr(110)}'")
    
    # a1[17] == 101 -> 'e'
    chars_14_24.append(chr(101))
    print(f"   [17]: {101} -> '{chr(101)}'")
    
    # a1[18] == 95 -> '_'
    chars_14_24.append(chr(95))
    print(f"   [18]: {95} -> '{chr(95)}'")
    
    # a1[19] - 57 == 248 -> a1[19] = 57 + 248 = 305 (mod 256) = 49 -> '1'
    val_19 = (57 + 248) & 0xFF
    chars_14_24.append(chr(val_19))
    print(f"   [19]: (57 + 248) & 0xFF = {val_19} -> '{chr(val_19)}'")
    
    # a1[20] == 115 -> 's'
    chars_14_24.append(chr(115))
    print(f"   [20]: {115} -> '{chr(115)}'")
    
    # a1[21] == 95 -> '_'
    chars_14_24.append(chr(95))
    print(f"   [21]: {95} -> '{chr(95)}'")
    
    # a1[22] - 116 == 237 -> a1[22] = 116 + 237 = 353 (mod 256) = 97 -> 'a'
    val_22 = (116 + 237) & 0xFF
    chars_14_24.append(chr(val_22))
    print(f"   [22]: (116 + 237) & 0xFF = {val_22} -> '{chr(val_22)}'")
    
    # a1[23] == 95 -> '_'
    chars_14_24.append(chr(95))
    print(f"   [23]: {95} -> '{chr(95)}'")
    
    # (a1[24] ^ 0x1B) == 0x75 -> a1[24] = 0x75 ^ 0x1B = 110 -> 'n'
    val_24 = 0x75 ^ 0x1B
    chars_14_24.append(chr(val_24))
    print(f"   [24]: 0x75 ^ 0x1B = {val_24} -> '{chr(val_24)}'")
    
    middle_part = ''.join(chars_14_24)
    print(f"\n   Middle part (14-24): '{middle_part}'")
    
    # Characters 25-31 are base64 encoded and checked
    print("\n4. Characters 25-31 (base64 encoded part):")
    # The base64 comparison checks against: 0x566430586C4E574D + 1027428685
    expected_b64_bytes = []
    
    # Convert the expected values to bytes
    val1 = 0x566430586C4E574D  # 8 bytes
    val2 = 1027428685          # 4 bytes
    
    # Extract bytes from val1 (little endian)
    for i in range(8):
        expected_b64_bytes.append((val1 >> (i * 8)) & 0xFF)
    
    # Extract bytes from val2 (little endian)  
    for i in range(4):
        expected_b64_bytes.append((val2 >> (i * 8)) & 0xFF)
    
    expected_b64_str = ''.join(chr(b) for b in expected_b64_bytes)
    print(f"   Expected base64 string: '{expected_b64_str}'")
    
    # Decode the base64
    try:
        decoded_bytes = base64.b64decode(expected_b64_str)
        decoded_str = decoded_bytes.decode('ascii', errors='ignore')
        print(f"   Base64 decoded: '{decoded_str}'")
    except:
        print("   Base64 decode failed, using raw string")
        decoded_str = expected_b64_str
    
    # Characters 32-46 are checked individually
    print("\n5. Characters 32-46 (final part):")
    chars_32_46 = []
    
    # a1[32] + 4 == 99 -> a1[32] = 95 -> '_'
    val_32 = 99 - 4
    chars_32_46.append(chr(val_32))
    print(f"   [32]: 99 - 4 = {val_32} -> '{chr(val_32)}'")
    
    # a1[33] == 108 -> 'l'
    chars_32_46.append(chr(108))
    print(f"   [33]: {108} -> '{chr(108)}'")
    
    # a1[34] == 105 -> 'i'
    chars_32_46.append(chr(105))
    print(f"   [34]: {105} -> '{chr(105)}'")
    
    # a1[35] - 103 == 251 -> a1[35] = 103 + 251 = 354 (mod 256) = 98 -> 'b'
    val_35 = (103 + 251) & 0xFF
    chars_32_46.append(chr(val_35))
    print(f"   [35]: (103 + 251) & 0xFF = {val_35} -> '{chr(val_35)}'")
    
    # a1[36] == 95 -> '_'
    chars_32_46.append(chr(95))
    print(f"   [36]: {95} -> '{chr(95)}'")
    
    # a1[37] == 102 -> 'f'
    chars_32_46.append(chr(102))
    print(f"   [37]: {102} -> '{chr(102)}'")
    
    # a1[38] == 48 -> '0'
    chars_32_46.append(chr(48))
    print(f"   [38]: {48} -> '{chr(48)}'")
    
    # a1[39] == 114 -> 'r'
    chars_32_46.append(chr(114))
    print(f"   [39]: {114} -> '{chr(114)}'")
    
    # a1[40] == 95 -> '_'
    chars_32_46.append(chr(95))
    print(f"   [40]: {95} -> '{chr(95)}'")
    
    # a1[41] == 103 -> 'g'
    chars_32_46.append(chr(103))
    print(f"   [41]: {103} -> '{chr(103)}'")
    
    # a1[42] == 48 -> '0'
    chars_32_46.append(chr(48))
    print(f"   [42]: {48} -> '{chr(48)}'")
    
    # a1[43] == 108 -> 'l'
    chars_32_46.append(chr(108))
    print(f"   [43]: {108} -> '{chr(108)}'")
    
    # a1[44] == 97 -> 'a'
    chars_32_46.append(chr(97))
    print(f"   [44]: {97} -> '{chr(97)}'")
    
    # a1[45] == 110 -> 'n'
    chars_32_46.append(chr(110))
    print(f"   [45]: {110} -> '{chr(110)}'")
    
    # a1[46] - 11 == 60 -> a1[46] = 71 -> 'G'
    val_46 = 60 + 11
    chars_32_46.append(chr(val_46))
    print(f"   [46]: 60 + 11 = {val_46} -> '{chr(val_46)}'")
    
    suffix = ''.join(chars_32_46)
    print(f"\n   Suffix (32-46): '{suffix}'")
    
    # Character 47 should be '}' to close the flag
    closing_brace = '}'
    print(f"\n6. Character 47: '{closing_brace}' (assumed closing brace)")
    
    # Construct the full flag
    full_flag = prefix + middle_part + decoded_str + suffix + closing_brace
    
    print(f"\n=== RECONSTRUCTED FLAG ===")
    print(f"Length: {len(full_flag)} characters")
    print(f"Flag: {full_flag}")
    
    # Verify length
    if len(full_flag) == 48:
        print("✓ Length matches expected 48 characters")
    else:
        print(f"✗ Length mismatch! Expected 48, got {len(full_flag)}")
        
        # Try different approach for base64 part
        print("\n=== Alternative Analysis ===")
        print("The base64 part might need different handling...")
        
        # Try to construct without base64 decoding
        alt_flag = prefix + middle_part + expected_b64_str + suffix + closing_brace
        print(f"Alternative flag: {alt_flag}")
        print(f"Alternative length: {len(alt_flag)}")

if __name__ == "__main__":
    decode_flag()
